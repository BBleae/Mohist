--- ../src-base/minecraft/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
+++ ../src-work/minecraft/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
@@ -1,21 +1,13 @@
 package net.minecraft.world.chunk.storage;
 
+import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.collect.Maps;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.annotation.Nullable;
 import net.minecraft.block.Block;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityList;
-import net.minecraft.nbt.CompressedStreamTools;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagList;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.datafix.DataFixer;
@@ -33,16 +25,37 @@
 import net.minecraft.world.storage.ThreadedFileIOBase;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.SupplierUtils;
 
+import javax.annotation.Nullable;
+import java.io.File;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
+import java.util.function.Supplier;
+
 public class AnvilChunkLoader implements IChunkLoader, IThreadedFileIO
 {
+    public ConcurrentLinkedQueue<QueuedChunk> queue = new ConcurrentLinkedQueue<>(); // Paper - Chunk queue improvements
+    private final Object lock = new Object(); // Paper - Chunk queue improvements
     private static final Logger LOGGER = LogManager.getLogger();
-    private final Map<ChunkPos, NBTTagCompound> chunksToSave = Maps.<ChunkPos, NBTTagCompound>newConcurrentMap();
+    private final ConcurrentMap<ChunkPos, Supplier<NBTTagCompound>> chunksToSave = Maps.newConcurrentMap();
     private final Set<ChunkPos> chunksBeingSaved = Collections.<ChunkPos>newSetFromMap(Maps.newConcurrentMap());
     public final File chunkSaveLocation;
     private final DataFixer fixer;
     private boolean flushing;
 
+    // Paper start
+    private long queuedSaves = 0;
+    private final java.util.concurrent.atomic.AtomicLong processedSaves = new java.util.concurrent.atomic.AtomicLong(0L);
+    public int getQueueSize() { return queue.size(); }
+    public long getQueuedSaves() { return queuedSaves; }
+    public long getProcessedSaves() { return processedSaves.longValue(); }
+    // Paper end
+
     public AnvilChunkLoader(File chunkSaveLocationIn, DataFixer dataFixerIn)
     {
         this.chunkSaveLocation = chunkSaveLocationIn;
@@ -75,27 +88,27 @@
     public Object[] loadChunk__Async(World worldIn, int x, int z) throws IOException
     {
         ChunkPos chunkpos = new ChunkPos(x, z);
-        NBTTagCompound nbttagcompound = this.chunksToSave.get(chunkpos);
+        Supplier<NBTTagCompound> nbttagcompound = this.chunksToSave.get(chunkpos);
 
         if (nbttagcompound == null)
         {
-            DataInputStream datainputstream = RegionFileCache.getChunkInputStream(this.chunkSaveLocation, x, z);
+            NBTTagCompound nbtTagCompound = RegionFileCache.getChunkInputStreamCB(this.chunkSaveLocation, x, z);
 
-            if (datainputstream == null)
+            if (nbtTagCompound == null)
             {
                 return null;
             }
 
-            nbttagcompound = this.fixer.process(FixTypes.CHUNK, CompressedStreamTools.read(datainputstream));
+            nbttagcompound = (Supplier<NBTTagCompound>) this.fixer.process(FixTypes.CHUNK, nbtTagCompound);
         }
 
-        return this.checkedReadChunkFromNBT__Async(worldIn, x, z, nbttagcompound);
+        return this.checkedReadChunkFromNBT__Async(worldIn, x, z, (NBTTagCompound) nbttagcompound);
     }
 
     public boolean isChunkGeneratedAt(int x, int z)
     {
         ChunkPos chunkpos = new ChunkPos(x, z);
-        NBTTagCompound nbttagcompound = this.chunksToSave.get(chunkpos);
+        NBTTagCompound nbttagcompound = (NBTTagCompound) this.chunksToSave.get(chunkpos);
         return nbttagcompound != null ? true : RegionFileCache.chunkExists(this.chunkSaveLocation, x, z);
     }
 
@@ -106,9 +119,23 @@
         return data != null ? (Chunk)data[0] : null;
     }
 
+    // Paper start
+    private static final int CURRENT_DATA_VERSION = 1343; // Paper
+    private static final boolean JUST_CORRUPT_IT = Boolean.valueOf("Paper.ignoreWorldDataVersion");
+    // Paper end
+
     @Nullable
     protected Object[] checkedReadChunkFromNBT__Async(World worldIn, int x, int z, NBTTagCompound compound)
     {
+        // Paper start - Do NOT attempt to load chunks saved with newer versions
+        if (compound.hasKey("DataVersion", 3)) {
+            int dataVersion = compound.getInteger("DataVersion");
+            if (!JUST_CORRUPT_IT && dataVersion > CURRENT_DATA_VERSION) {
+                new RuntimeException("Server attempted to load chunk saved with newer version of minecraft! " + dataVersion + " > " + CURRENT_DATA_VERSION).printStackTrace();
+                System.exit(1);
+            }
+        }
+        // Paper end
         if (!compound.hasKey("Level", 10))
         {
             LOGGER.error("Chunk file at {},{} is missing level data, skipping", Integer.valueOf(x), Integer.valueOf(z));
@@ -162,7 +189,7 @@
     public void saveChunk(World worldIn, Chunk chunkIn) throws MinecraftException, IOException
     {
         worldIn.checkSessionLock();
-
+        int attempts = 0; Exception laste = null; while (attempts++ < 5) { // Paper
         try
         {
             NBTTagCompound nbttagcompound = new NBTTagCompound();
@@ -173,63 +200,67 @@
             this.writeChunkToNBT(chunkIn, worldIn, nbttagcompound1);
             net.minecraftforge.common.ForgeChunkManager.storeChunkNBT(chunkIn, nbttagcompound1);
             net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkDataEvent.Save(chunkIn, nbttagcompound));
-            this.addChunkToPending(chunkIn.getPos(), nbttagcompound);
+            this.addChunkToPending(chunkIn.getPos(), (Supplier<NBTTagCompound>) nbttagcompound);
         }
         catch (Exception exception)
         {
-            LOGGER.error("Failed to save chunk", (Throwable)exception);
+            laste = exception; // Paper
         }
+        try {Thread.sleep(10);} catch (InterruptedException e) {e.printStackTrace();} } // Paper
+        if (laste != null) { com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(laste); MinecraftServer.LOGGER.error("Failed to save chunk", laste); } // Paper
     }
 
-    protected void addChunkToPending(ChunkPos pos, NBTTagCompound compound)
+    protected void addChunkToPending(ChunkPos pos, Supplier<NBTTagCompound> compound)
     {
-        if (!this.chunksBeingSaved.contains(pos))
+        synchronized (this.lock)
         {
             this.chunksToSave.put(pos, compound);
         }
-
+        queuedSaves++; // Paper
+        this.queue.add(new QueuedChunk(pos, compound));
         ThreadedFileIOBase.getThreadedIOInstance().queueIO(this);
     }
 
     public boolean writeNextIO()
     {
-        if (this.chunksToSave.isEmpty())
+        return processSaveQueueEntry(false);
+    }
+
+    public boolean processSaveQueueEntry(boolean logCompletion)
+    {
+        // CraftBukkit start
+        // Paper start - Chunk queue improvements
+        QueuedChunk chunk = this.queue.poll();
+        if (chunk == null)
         {
-            if (this.flushing)
-            {
-                LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", (Object)this.chunkSaveLocation.getName());
+            if (logCompletion) {
+                LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", this.chunkSaveLocation.getName());
             }
-
             return false;
         }
-        else
-        {
-            ChunkPos chunkpos = this.chunksToSave.keySet().iterator().next();
+        else {
+            ChunkPos chunkpos = chunk.coords; // Paper - Chunk queue improvements
             boolean lvt_3_1_;
 
-            try
-            {
-                this.chunksBeingSaved.add(chunkpos);
-                NBTTagCompound nbttagcompound = this.chunksToSave.remove(chunkpos);
-
-                if (nbttagcompound != null)
-                {
-                    try
-                    {
+            try {
+                NBTTagCompound nbttagcompound = SupplierUtils.getIfExists(chunk.compoundSupplier); // Spigot // Paper
+                // CraftBukkit
+                if (nbttagcompound != null) {
+                    try {
                         this.writeChunkData(chunkpos, nbttagcompound);
+                    } catch (Exception exception) {
+                        LOGGER.error("Failed to save chunk", exception);
                     }
-                    catch (Exception exception)
-                    {
-                        LOGGER.error("Failed to save chunk", (Throwable)exception);
+                }
+                // Paper - This will not equal if a newer version is still pending
+                synchronized (this.lock) {
+                    if (this.chunksToSave.get(chunkpos) == chunk.compoundSupplier) {
+                        this.chunksToSave.remove(chunkpos);
                     }
                 }
-
                 lvt_3_1_ = true;
+            } finally {
             }
-            finally
-            {
-                this.chunksBeingSaved.remove(chunkpos);
-            }
 
             return lvt_3_1_;
         }
@@ -237,9 +268,10 @@
 
     private void writeChunkData(ChunkPos pos, NBTTagCompound compound) throws IOException
     {
-        DataOutputStream dataoutputstream = RegionFileCache.getChunkOutputStream(this.chunkSaveLocation, pos.x, pos.z);
-        CompressedStreamTools.write(compound, dataoutputstream);
-        dataoutputstream.close();
+        // DataOutputStream dataoutputstream = RegionFileCache.getChunkOutputStream(this.chunkSaveLocation, pos.x, pos.z);
+        // CompressedStreamTools.write(compound, dataoutputstream);
+        // dataoutputstream.close();
+        RegionFileCache.getChunkOutputStream(this.chunkSaveLocation, pos.x, pos.z, compound);
     }
 
     public void saveExtraChunkData(World worldIn, Chunk chunkIn) throws IOException
@@ -349,13 +381,22 @@
         compound.setByteArray("Biomes", chunkIn.getBiomeArray());
         chunkIn.setHasEntities(false);
         NBTTagList nbttaglist1 = new NBTTagList();
-
+        List<Entity> toUpdate = new java.util.ArrayList<>(); // Paper
         for (int i = 0; i < chunkIn.getEntityLists().length; ++i)
         {
             for (Entity entity : chunkIn.getEntityLists()[i])
             {
                 NBTTagCompound nbttagcompound2 = new NBTTagCompound();
-
+                // Paper start
+                if ((int)Math.floor(entity.posX) >> 4 != chunkIn.x || (int)Math.floor(entity.posZ) >> 4 != chunkIn.z) {
+                    LogManager.getLogger().warn(entity + " is not in this chunk, skipping save. This a bug fix to a vanilla bug. Do not report this to PaperMC please.");
+                    toUpdate.add(entity);
+                    continue;
+                }
+                if (entity.isDead) {
+                    continue;
+                }
+                // Paper end
                 try
                 {
                 if (entity.writeToNBTOptional(nbttagcompound2))
@@ -366,12 +407,15 @@
                 }
                 catch (Exception e)
                 {
-                    net.minecraftforge.fml.common.FMLLog.log.error("An Entity type {} has thrown an exception trying to write state. It will not persist. Report this to the mod author",
-                            entity.getClass().getName(), e);
+                    LOGGER.error("An Entity type {} has thrown an exception trying to write state. It will not persist. Report this to the mod author", entity.getClass().getName(), e);
                 }
             }
         }
-
+        // Paper start - move entities to the correct chunk
+        for (Entity entity : toUpdate) {
+            worldIn.updateEntityWithOptionalForce(entity, false);
+        }
+        // Paper end
         compound.setTag("Entities", nbttaglist1);
         NBTTagList nbttaglist2 = new NBTTagList();
 
@@ -384,7 +428,7 @@
             }
             catch (Exception e)
             {
-                net.minecraftforge.fml.common.FMLLog.log.error("A TileEntity type {} has throw an exception trying to write state. It will not persist. Report this to the mod author",
+                LOGGER.error("A TileEntity type {} has throw an exception trying to write state. It will not persist. Report this to the mod author",
                         tileentity.getClass().getName(), e);
             }
         }
@@ -421,7 +465,7 @@
             }
             catch (Exception exception)
             {
-                net.minecraftforge.fml.common.FMLLog.log.error("A capability provider has thrown an exception trying to write state. It will not persist. Report this to the mod author", exception);
+                LOGGER.error("A capability provider has thrown an exception trying to write state. It will not persist. Report this to the mod author", exception);
             }
         }
     }
@@ -485,7 +529,6 @@
             readChunkEntity(nbttagcompound1, worldIn, chunk);
             chunk.setHasEntities(true);
         }
-
         NBTTagList nbttaglist2 = compound.getTagList("TileEntities", 10);
 
         for (int k1 = 0; k1 < nbttaglist2.tagCount(); ++k1)
@@ -498,7 +541,6 @@
                 chunk.addTileEntity(tileentity);
             }
         }
-
         if (compound.hasKey("TileTicks", 9))
         {
             NBTTagList nbttaglist3 = compound.getTagList("TileTicks", 10);
@@ -608,8 +650,11 @@
 
     public static void spawnEntity(Entity entityIn, World worldIn)
     {
-        if (worldIn.spawnEntity(entityIn) && entityIn.isBeingRidden())
-        {
+        spawnEntity(entityIn, worldIn, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    public static void spawnEntity(Entity entityIn, World worldIn, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+        if (!entityIn.valid && worldIn.addEntity(entityIn, reason) && entityIn.isBeingRidden()) {
             for (Entity entity : entityIn.getPassengers())
             {
                 spawnEntity(entity, worldIn);
@@ -655,4 +700,18 @@
     {
         return this.chunksToSave.size();
     }
+
+    // Paper start - Chunk queue improvements
+    private static class QueuedChunk
+    {
+        public ChunkPos coords;
+        public Supplier<NBTTagCompound> compoundSupplier;
+
+        public QueuedChunk(ChunkPos coords, Supplier<NBTTagCompound> compoundSupplier)
+        {
+            this.coords = coords;
+            this.compoundSupplier = compoundSupplier;
+        }
+    }
+    // Paper end
 }
